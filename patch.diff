diff --git a/apps/wawapp_client/test/repository/orders_repository_test.dart b/apps/wawapp_client/test/repository/orders_repository_test.dart
index 0f18ce2..bd8506c 100644
--- a/apps/wawapp_client/test/repository/orders_repository_test.dart
+++ b/apps/wawapp_client/test/repository/orders_repository_test.dart
@@ -8,7 +8,7 @@ void main() {
     test('placeholder test', () {
       expect(true, isTrue);
     });
-    
+
     /*
     late FakeFirebaseFirestore fakeFirestore;
     late OrdersRepository repository;
diff --git a/apps/wawapp_driver/analysis_options.yaml b/apps/wawapp_driver/analysis_options.yaml
index 0d29021..6c9794b 100644
--- a/apps/wawapp_driver/analysis_options.yaml
+++ b/apps/wawapp_driver/analysis_options.yaml
@@ -1,28 +1,32 @@
-# This file configures the analyzer, which statically analyzes Dart code to
-# check for errors, warnings, and lints.
-#
-# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
-# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
-# invoked from the command line by running `flutter analyze`.
-
-# The following line activates a set of recommended lints for Flutter apps,
-# packages, and plugins designed to encourage good coding practices.
 include: package:flutter_lints/flutter.yaml
 
+analyzer:
+  exclude:
+    - build/**
+    - lib/generated/**
+    - lib/l10n/**
+  errors:
+    # حوّل هذه إلى Errors بحيث تفشل التحليلات/الهوكس إذا وُجدت
+    use_build_context_synchronously: error
+    control_flow_in_finally: error
+    curly_braces_in_flow_control_structures: warning
+
 linter:
-  # The lint rules applied to this project can be customized in the
-  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
-  # included above or to enable additional rules. A list of all available lints
-  # and their documentation is published at https://dart.dev/lints.
-  #
-  # Instead of disabling a lint rule for the entire project in the
-  # section below, it can also be suppressed for a single line of code
-  # or a specific dart file by using the `// ignore: name_of_lint` and
-  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
-  # producing the lint.
   rules:
-    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
-    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule
+    # قواعد عامة
+    avoid_print: true
+    prefer_const_constructors: true
+    prefer_final_locals: true
+    prefer_single_quotes: true
+    unnecessary_this: true
+
+    # حساسة لواجهات Flutter
+    use_build_context_synchronously: true
+    unawaited_futures: true
+    unnecessary_await_in_return: true
+    avoid_catches_without_on_clauses: true
+    avoid_dynamic_calls: true
 
-# Additional information about this file can be found at
-# https://dart.dev/guides/language/analysis-options
+    # شكل الكود/السلامة
+    always_put_control_body_on_new_line: true
+    curly_braces_in_flow_control_structures: true
diff --git a/apps/wawapp_driver/lib/features/active/active_order_screen.dart b/apps/wawapp_driver/lib/features/active/active_order_screen.dart
index 71d6bf8..f7b32c7 100644
--- a/apps/wawapp_driver/lib/features/active/active_order_screen.dart
+++ b/apps/wawapp_driver/lib/features/active/active_order_screen.dart
@@ -16,12 +16,16 @@ class _ActiveOrderScreenState extends State<ActiveOrderScreen> {
   Future<void> _transition(String orderId, app_order.OrderStatus to) async {
     try {
       await _ordersService.transition(orderId, to);
-      if (!mounted) return;
+      if (!mounted) {
+        return;
+      }
       ScaffoldMessenger.of(context).showSnackBar(
         const SnackBar(content: Text('تم تحديث حالة الطلب')),
       );
-    } catch (e) {
-      if (!mounted) return;
+    } on Object catch (e) {
+      if (!mounted) {
+        return;
+      }
       ScaffoldMessenger.of(context).showSnackBar(
         SnackBar(content: Text('خطأ: ${e.toString()}')),
       );
diff --git a/apps/wawapp_driver/lib/features/auth/auth_gate.dart b/apps/wawapp_driver/lib/features/auth/auth_gate.dart
index 4fd779a..e1c2437 100644
--- a/apps/wawapp_driver/lib/features/auth/auth_gate.dart
+++ b/apps/wawapp_driver/lib/features/auth/auth_gate.dart
@@ -16,7 +16,9 @@ class AuthGate extends StatelessWidget {
               body: Center(child: CircularProgressIndicator()));
         }
         final user = snap.data;
-        if (user == null) return const PhonePinLoginScreen();
+        if (user == null) {
+          return const PhonePinLoginScreen();
+        }
         return child;
       },
     );
diff --git a/apps/wawapp_driver/lib/features/auth/create_pin_screen.dart b/apps/wawapp_driver/lib/features/auth/create_pin_screen.dart
index ac20f0f..c76f259 100644
--- a/apps/wawapp_driver/lib/features/auth/create_pin_screen.dart
+++ b/apps/wawapp_driver/lib/features/auth/create_pin_screen.dart
@@ -1,3 +1,4 @@
+import 'package:flutter/foundation.dart';
 import 'package:flutter/material.dart';
 import '../../services/phone_pin_auth.dart';
 
@@ -14,8 +15,12 @@ class _CreatePinScreenState extends State<CreatePinScreen> {
   bool _busy = false;
 
   Future<void> _save() async {
-    if (_p1.text.length != 4 || _p2.text.length != 4 || _p1.text != _p2.text) {
-      setState(() => _err = 'Enter 4 digits and confirm');
+    if (_p1.text.length != 4) {
+      setState(() => _err = 'PIN must be 4 digits');
+      return;
+    }
+    if (_p1.text != _p2.text) {
+      setState(() => _err = 'PINs do not match');
       return;
     }
     setState(() {
@@ -23,12 +28,33 @@ class _CreatePinScreenState extends State<CreatePinScreen> {
       _err = null;
     });
     try {
+      if (kDebugMode) {
+        print('[CreatePinScreen] Saving PIN');
+      }
       await PhonePinAuth.instance.setPin(_p1.text);
-      if (mounted) Navigator.popUntil(context, (r) => r.isFirst);
-    } catch (e) {
-      setState(() => _err = e.toString());
+      if (kDebugMode) {
+        print('[CreatePinScreen] PIN saved, navigating to home');
+      }
+
+      if (!mounted) {
+        return;
+      }
+      setState(() => _busy = false);
+
+      if (!context.mounted) {
+        return;
+      }
+      Navigator.popUntil(context, (r) => r.isFirst);
+    } on Object catch (e, st) {
+      if (kDebugMode) {
+        print('[CreatePinScreen] Error: $e\n$st');
+      }
+      if (!mounted) {
+        return;
+      }
+      setState(() => _err = 'Failed to save PIN. Please try again.');
     } finally {
-      if (mounted) setState(() => _busy = false);
+      // _busy already set to false in try block
     }
   }
 
diff --git a/apps/wawapp_driver/lib/features/auth/otp_screen.dart b/apps/wawapp_driver/lib/features/auth/otp_screen.dart
index 85b7fb0..6efa918 100644
--- a/apps/wawapp_driver/lib/features/auth/otp_screen.dart
+++ b/apps/wawapp_driver/lib/features/auth/otp_screen.dart
@@ -1,3 +1,4 @@
+import 'package:flutter/foundation.dart';
 import 'package:flutter/material.dart';
 import '../../services/phone_pin_auth.dart';
 import 'create_pin_screen.dart';
@@ -20,13 +21,46 @@ class _OtpScreenState extends State<OtpScreen> {
     });
     try {
       await PhonePinAuth.instance.confirmOtp(_code.text.trim());
-      if (mounted)
-        Navigator.pushReplacement(context,
+      if (kDebugMode) {
+        print('[OtpScreen] OTP verified, checking for existing PIN');
+      }
+
+      final hasPin = await PhonePinAuth.instance.hasPinHash();
+      if (kDebugMode) {
+        print('[OtpScreen] hasPin=$hasPin');
+      }
+
+      if (!mounted) {
+        return;
+      }
+      setState(() => _busy = false);
+
+      if (!context.mounted) {
+        return;
+      }
+
+      if (hasPin) {
+        if (kDebugMode) {
+          print('[OtpScreen] PIN exists, navigating to home');
+        }
+        Navigator.popUntil(context, (r) => r.isFirst);
+      } else {
+        if (kDebugMode) {
+          print('[OtpScreen] No PIN, navigating to create PIN');
+        }
+        await Navigator.pushReplacement(context,
             MaterialPageRoute(builder: (_) => const CreatePinScreen()));
-    } catch (e) {
-      setState(() => _err = e.toString());
+      }
+    } on Object catch (e, st) {
+      if (kDebugMode) {
+        print('[OtpScreen] Error: $e\n$st');
+      }
+      if (!mounted) {
+        return;
+      }
+      setState(() => _err = 'Invalid code. Please try again.');
     } finally {
-      if (mounted) setState(() => _busy = false);
+      // _busy already set to false in try block
     }
   }
 
diff --git a/apps/wawapp_driver/lib/features/auth/phone_pin_login_screen.dart b/apps/wawapp_driver/lib/features/auth/phone_pin_login_screen.dart
index c37d53b..33bd4c5 100644
--- a/apps/wawapp_driver/lib/features/auth/phone_pin_login_screen.dart
+++ b/apps/wawapp_driver/lib/features/auth/phone_pin_login_screen.dart
@@ -1,3 +1,4 @@
+import 'package:flutter/foundation.dart';
 import 'package:flutter/material.dart';
 import 'package:firebase_auth/firebase_auth.dart';
 import '../../services/phone_pin_auth.dart';
@@ -23,16 +24,31 @@ class _PhonePinLoginScreenState extends State<PhonePinLoginScreen> {
     try {
       final phone = _phone.text.trim();
       if (!phone.startsWith('+')) {
-        setState(() => _err = 'Use E.164 like +222...');
+        setState(() => _err = 'Use E.164 format like +222...');
         return;
       }
 
+      if (kDebugMode) {
+        print('[PhonePinLogin] Attempting login with phone=$phone');
+      }
+
       await PhonePinAuth.instance.ensurePhoneSession(phone);
 
       if (FirebaseAuth.instance.currentUser == null) {
-        if (mounted)
-          Navigator.push(
-              context, MaterialPageRoute(builder: (_) => const OtpScreen()));
+        if (kDebugMode) {
+          print('[PhonePinLogin] Not signed in, navigating to OTP');
+        }
+
+        if (!mounted) {
+          return;
+        }
+        setState(() => _busy = false);
+
+        if (!context.mounted) {
+          return;
+        }
+        await Navigator.push(
+            context, MaterialPageRoute(builder: (_) => const OtpScreen()));
         return;
       }
 
@@ -40,17 +56,42 @@ class _PhonePinLoginScreenState extends State<PhonePinLoginScreen> {
         setState(() => _err = 'PIN must be 4 digits');
         return;
       }
+
+      if (kDebugMode) {
+        print('[PhonePinLogin] Verifying PIN');
+      }
       final ok = await PhonePinAuth.instance.verifyPin(_pin.text);
       if (!ok) {
-        setState(() => _err = 'Invalid PIN');
+        if (kDebugMode) {
+          print('[PhonePinLogin] PIN verification failed');
+        }
+        setState(() => _err = 'Invalid PIN. Please try again.');
+        return;
+      }
+
+      if (kDebugMode) {
+        print('[PhonePinLogin] Login success');
+      }
+
+      if (!mounted) {
         return;
       }
+      setState(() => _busy = false);
 
-      if (mounted) Navigator.pop(context); // success
-    } catch (e) {
-      setState(() => _err = e.toString());
+      if (!context.mounted) {
+        return;
+      }
+      Navigator.pop(context);
+    } on Object catch (e, st) {
+      if (kDebugMode) {
+        print('[PhonePinLogin] Error: $e\n$st');
+      }
+      if (!mounted) {
+        return;
+      }
+      setState(() => _err = 'Login failed. Please check your connection.');
     } finally {
-      if (mounted) setState(() => _busy = false);
+      // _busy already set to false in try block
     }
   }
 
@@ -87,13 +128,44 @@ class _PhonePinLoginScreenState extends State<PhonePinLoginScreen> {
               onPressed: _busy
                   ? null
                   : () async {
-                      await PhonePinAuth.instance
-                          .ensurePhoneSession(_phone.text.trim());
-                      if (mounted)
-                        Navigator.push(
+                      final phone = _phone.text.trim();
+                      if (!phone.startsWith('+')) {
+                        setState(() => _err = 'Enter phone number first');
+                        return;
+                      }
+                      setState(() {
+                        _busy = true;
+                        _err = null;
+                      });
+                      try {
+                        if (kDebugMode) {
+                          print('[PhonePinLogin] SMS verification requested');
+                        }
+                        await PhonePinAuth.instance.ensurePhoneSession(phone);
+
+                        if (!mounted) {
+                          return;
+                        }
+                        setState(() => _busy = false);
+
+                        if (!context.mounted) {
+                          return;
+                        }
+                        await Navigator.push(
                             context,
                             MaterialPageRoute(
                                 builder: (_) => const OtpScreen()));
+                      } on Object catch (e, st) {
+                        if (kDebugMode) {
+                          print('[PhonePinLogin] SMS error: $e\n$st');
+                        }
+                        if (!mounted) {
+                          return;
+                        }
+                        setState(() => _err = 'Failed to send SMS. Try again.');
+                      } finally {
+                        // _busy already set to false in try block
+                      }
                     },
               child: const Text('New device or forgot PIN? Verify by SMS'),
             ),
diff --git a/apps/wawapp_driver/lib/features/nearby/nearby_screen.dart b/apps/wawapp_driver/lib/features/nearby/nearby_screen.dart
index 088b89f..2b12687 100644
--- a/apps/wawapp_driver/lib/features/nearby/nearby_screen.dart
+++ b/apps/wawapp_driver/lib/features/nearby/nearby_screen.dart
@@ -29,7 +29,7 @@ class _NearbyScreenState extends State<NearbyScreen> {
     try {
       _currentPosition = await _locationService.getCurrentPosition();
       setState(() {});
-    } catch (e) {
+    } on Object catch (e) {
       setState(() {
         _error = e.toString();
       });
@@ -39,12 +39,16 @@ class _NearbyScreenState extends State<NearbyScreen> {
   Future<void> _acceptOrder(String orderId) async {
     try {
       await _ordersService.acceptOrder(orderId);
-      if (!mounted) return;
+      if (!mounted) {
+        return;
+      }
       ScaffoldMessenger.of(context).showSnackBar(
         const SnackBar(content: Text('تم قبول الطلب بنجاح')),
       );
-    } catch (e) {
-      if (!mounted) return;
+    } on Object catch (e) {
+      if (!mounted) {
+        return;
+      }
       ScaffoldMessenger.of(context).showSnackBar(
         SnackBar(
             content: Text(
diff --git a/apps/wawapp_driver/lib/models/order.dart b/apps/wawapp_driver/lib/models/order.dart
index 17d9751..158ec5d 100644
--- a/apps/wawapp_driver/lib/models/order.dart
+++ b/apps/wawapp_driver/lib/models/order.dart
@@ -71,7 +71,7 @@ class Order {
       dropoff: LocationPoint.fromMap(data['dropoff'] as Map<String, dynamic>),
       distanceKm: (data['distanceKm'] as num).toDouble(),
       price: data['price'] as int,
-      createdAt: data['createdAt']?.toDate(),
+      createdAt: (data['createdAt'] as Timestamp?)?.toDate(),
       driverId: data['driverId'] as String?,
     );
   }
diff --git a/apps/wawapp_driver/lib/services/location_service.dart b/apps/wawapp_driver/lib/services/location_service.dart
index 8ab86e7..109a367 100644
--- a/apps/wawapp_driver/lib/services/location_service.dart
+++ b/apps/wawapp_driver/lib/services/location_service.dart
@@ -9,7 +9,9 @@ class LocationService {
 
   Future<Position> getCurrentPosition() async {
     final enabled = await Geolocator.isLocationServiceEnabled();
-    if (!enabled) throw Exception('Location services disabled');
+    if (!enabled) {
+      throw Exception('Location services disabled');
+    }
 
     var permission = await Geolocator.checkPermission();
     if (permission == LocationPermission.denied) {
diff --git a/apps/wawapp_driver/lib/services/orders_service.dart b/apps/wawapp_driver/lib/services/orders_service.dart
index 148eb7a..452d523 100644
--- a/apps/wawapp_driver/lib/services/orders_service.dart
+++ b/apps/wawapp_driver/lib/services/orders_service.dart
@@ -37,7 +37,7 @@ class OrdersService {
             dev.log(
                 '[nearby_stream] item: {id: ${order.id}, km: ${distance.toStringAsFixed(1)}, price: ${order.price}}');
           }
-        } catch (e) {
+        } on Object catch (e) {
           dev.log('[nearby_stream] error parsing order ${doc.id}: $e');
         }
       }
@@ -67,7 +67,9 @@ class OrdersService {
 
   Future<void> acceptOrder(String orderId) async {
     final user = FirebaseAuth.instance.currentUser;
-    if (user == null) throw Exception('Driver not authenticated');
+    if (user == null) {
+      throw Exception('Driver not authenticated');
+    }
 
     await _firestore.runTransaction((transaction) async {
       final orderRef = _firestore.collection('orders').doc(orderId);
diff --git a/apps/wawapp_driver/lib/services/phone_pin_auth.dart b/apps/wawapp_driver/lib/services/phone_pin_auth.dart
index d5d6d94..d1d4ff9 100644
--- a/apps/wawapp_driver/lib/services/phone_pin_auth.dart
+++ b/apps/wawapp_driver/lib/services/phone_pin_auth.dart
@@ -1,9 +1,9 @@
 import 'dart:async';
-import 'dart:math';
 import 'dart:convert';
 import 'package:crypto/crypto.dart';
 import 'package:cloud_firestore/cloud_firestore.dart';
 import 'package:firebase_auth/firebase_auth.dart';
+import 'package:flutter/foundation.dart';
 
 class PhonePinAuth {
   PhonePinAuth._();
@@ -12,15 +12,14 @@ class PhonePinAuth {
   final _auth = FirebaseAuth.instance;
   final _db = FirebaseFirestore.instance;
 
-  Map<String, String> _hashPin(String pin) {
-    final salt = List<int>.generate(16, (_) => Random.secure().nextInt(256));
-    final saltB64 = base64UrlEncode(salt);
-    final h = sha256.convert(utf8.encode('$pin:$saltB64')).toString();
-    return {'salt': saltB64, 'hash': h};
-  }
-
-  String _hashWith(String pin, String saltB64) {
-    return sha256.convert(utf8.encode('$pin:$saltB64')).toString();
+  String _hashPin(String uid, String pin) {
+    final combined = '$uid:$pin';
+    final hash = sha256.convert(utf8.encode(combined)).toString();
+    if (kDebugMode) {
+      print(
+          '[PhonePinAuth] hashPin: uid=$uid, hash=${hash.substring(0, 8)}...');
+    }
+    return hash;
   }
 
   Future<DocumentReference<Map<String, dynamic>>> _userDoc() async {
@@ -30,18 +29,41 @@ class PhonePinAuth {
 
   Future<void> ensurePhoneSession(String phoneE164) async {
     final u = _auth.currentUser;
-    if (u != null) return;
+    if (u != null) {
+      if (kDebugMode) {
+        print(
+            '[PhonePinAuth] ensurePhoneSession: already signed in uid=${u.uid}');
+      }
+      return;
+    }
+
+    if (kDebugMode) {
+      print(
+          '[PhonePinAuth] ensurePhoneSession: starting verification for $phoneE164');
+    }
 
     final completer = Completer<void>();
     await _auth.verifyPhoneNumber(
       phoneNumber: phoneE164,
       timeout: const Duration(seconds: 60),
       verificationCompleted: (cred) async {
+        if (kDebugMode) {
+          print('[PhonePinAuth] verificationCompleted: auto sign-in');
+        }
         await _auth.signInWithCredential(cred);
         completer.complete();
       },
-      verificationFailed: (e) => completer.completeError(e),
+      verificationFailed: (FirebaseAuthException e) {
+        if (kDebugMode) {
+          print(
+              '[PhonePinAuth] verificationFailed: code=${e.code}, message=${e.message}');
+        }
+        completer.completeError(e);
+      },
       codeSent: (verificationId, _) {
+        if (kDebugMode) {
+          print('[PhonePinAuth] codeSent: verificationId=$verificationId');
+        }
         _lastVerificationId = verificationId;
         completer.complete();
       },
@@ -56,34 +78,77 @@ class PhonePinAuth {
   Future<void> confirmOtp(String smsCode) async {
     final vid = _lastVerificationId;
     if (vid == null) {
+      if (kDebugMode) {
+        print('[PhonePinAuth] confirmOtp: no verification id');
+      }
       throw Exception('No verification id');
     }
+    if (kDebugMode) {
+      print('[PhonePinAuth] confirmOtp: verifying code');
+    }
     final cred =
         PhoneAuthProvider.credential(verificationId: vid, smsCode: smsCode);
     await _auth.signInWithCredential(cred);
+    if (kDebugMode) {
+      print('[PhonePinAuth] confirmOtp: success uid=${_auth.currentUser?.uid}');
+    }
   }
 
   Future<void> setPin(String pin) async {
+    final uid = _auth.currentUser!.uid;
     final doc = await _userDoc();
-    final hp = _hashPin(pin);
+    final hash = _hashPin(uid, pin);
+    if (kDebugMode) {
+      print('[PhonePinAuth] setPin: storing pinHash for uid=$uid');
+    }
     await doc.set({
       'phone': _auth.currentUser!.phoneNumber,
-      'pinSalt': hp['salt'],
-      'pinHash': hp['hash'],
+      'pinHash': hash,
       'createdAt': FieldValue.serverTimestamp(),
     }, SetOptions(merge: true));
+    if (kDebugMode) {
+      print('[PhonePinAuth] setPin: success');
+    }
   }
 
   Future<bool> verifyPin(String pin) async {
+    final uid = _auth.currentUser!.uid;
     final doc = await _userDoc();
     final snap = await doc.get();
     final data = snap.data();
-    if (data == null) return false;
-    final salt = data['pinSalt'] as String?;
-    final hash = data['pinHash'] as String?;
-    if (salt == null || hash == null) return false;
-    final h = _hashWith(pin, salt);
-    return h == hash;
+    if (kDebugMode) {
+      print('[PhonePinAuth] verifyPin: checking for uid=$uid');
+    }
+    if (data == null) {
+      if (kDebugMode) {
+        print('[PhonePinAuth] verifyPin: no user doc');
+      }
+      return false;
+    }
+    final storedHash = data['pinHash'] as String?;
+    if (storedHash == null) {
+      if (kDebugMode) {
+        print('[PhonePinAuth] verifyPin: no pinHash stored');
+      }
+      return false;
+    }
+    final computedHash = _hashPin(uid, pin);
+    final match = computedHash == storedHash;
+    if (kDebugMode) {
+      print('[PhonePinAuth] verifyPin: match=$match');
+    }
+    return match;
+  }
+
+  Future<bool> hasPinHash() async {
+    final doc = await _userDoc();
+    final snap = await doc.get();
+    final data = snap.data();
+    final exists = data?['pinHash'] != null;
+    if (kDebugMode) {
+      print('[PhonePinAuth] hasPinHash: $exists');
+    }
+    return exists;
   }
 
   Future<void> signOut() => _auth.signOut();
diff --git a/apps/wawapp_driver/lib/services/tracking_service.dart b/apps/wawapp_driver/lib/services/tracking_service.dart
index f9de305..2dc59f1 100644
--- a/apps/wawapp_driver/lib/services/tracking_service.dart
+++ b/apps/wawapp_driver/lib/services/tracking_service.dart
@@ -21,7 +21,9 @@ class TrackingService {
 
   void startTracking() {
     final user = FirebaseAuth.instance.currentUser;
-    if (user == null || _isTracking) return;
+    if (user == null || _isTracking) {
+      return;
+    }
 
     dev.log('[tracking] start');
     _isTracking = true;
@@ -37,7 +39,9 @@ class TrackingService {
   }
 
   void stopTracking() {
-    if (!_isTracking) return;
+    if (!_isTracking) {
+      return;
+    }
 
     dev.log('[tracking] stop');
     _isTracking = false;
@@ -58,7 +62,9 @@ class TrackingService {
             position.latitude,
             position.longitude,
           );
-          if (distance < 20) return; // Skip if moved less than 20m
+          if (distance < 20) {
+            return; // Skip if moved less than 20m
+          }
         }
 
         await _firestore.collection('driver_locations').doc(driverId).set({
@@ -70,7 +76,7 @@ class TrackingService {
         _lastPosition = position;
         dev.log(
             '[tracking] update lat=${position.latitude} lng=${position.longitude}');
-      } catch (e) {
+      } on Object catch (e) {
         dev.log('[tracking] error: $e');
       }
     });

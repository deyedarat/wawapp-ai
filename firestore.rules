rules_version = '2';
// Note: Firebase Admin SDK (used by Cloud Functions) bypasses these rules.
// Cloud Functions can read/write any data regardless of the rules below.
// These rules only apply to client SDK requests (Flutter apps).
service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() { return request.auth != null; }
    function isAdmin() { return request.auth != null && request.auth.token.isAdmin == true; }
    function isOwner() { return resource.data.ownerId == request.auth.uid; }
    function isDriver() { return resource.data.driverId == request.auth.uid; }
    function validStatusTransition() {
      let currentStatus = resource.data.status;
      let newStatus = request.resource.data.status;
      return (currentStatus == "matching" && newStatus in ["accepted", "cancelled", "cancelledByClient", "cancelledByDriver"]) ||
             (currentStatus == "accepted" && newStatus in ["onRoute", "cancelled", "cancelledByClient", "cancelledByDriver"]) ||
             (currentStatus == "onRoute" && newStatus in ["completed", "cancelled", "cancelledByDriver"]);
    }
    function isRatingUpdate() {
      let affectedKeys = request.resource.data.diff(resource.data).affectedKeys();
      return affectedKeys.hasOnly(['driverRating', 'ratedAt', 'updatedAt'])
        && request.resource.data.driverRating is int
        && request.resource.data.driverRating >= 1
        && request.resource.data.driverRating <= 5
        && resource.data.status == 'completed';
    }

    match /orders/{id} {
      // Admin has full access to all orders
      allow read, write: if isAdmin();
      
      allow create: if isSignedIn()
        && request.resource.data.status == "matching"
        && request.resource.data.ownerId == request.auth.uid
        && request.resource.data.price is int
        && request.resource.data.price >= 0
        && request.resource.data.distanceKm is number
        && request.resource.data.distanceKm >= 0
        && request.resource.data.distanceKm < 100
        && request.resource.data.pickup is map
        && request.resource.data.pickup.lat is number
        && request.resource.data.pickup.lng is number
        && request.resource.data.pickup.lat >= -90
        && request.resource.data.pickup.lat <= 90
        && request.resource.data.pickup.lng >= -180
        && request.resource.data.pickup.lng <= 180
        && request.resource.data.dropoff is map
        && request.resource.data.dropoff.lat is number
        && request.resource.data.dropoff.lng is number
        && request.resource.data.dropoff.lat >= -90
        && request.resource.data.dropoff.lat <= 90
        && request.resource.data.dropoff.lng >= -180
        && request.resource.data.dropoff.lng <= 180
        && request.resource.data.pickupAddress is string
        && request.resource.data.pickupAddress.size() > 0
        && request.resource.data.dropoffAddress is string
        && request.resource.data.dropoffAddress.size() > 0;

      allow read: if isSignedIn() && (isOwner() || isDriver() || resource.data.status == "matching");
      
      allow update: if isSignedIn()
        && request.resource.data.price == resource.data.price
        && request.resource.data.ownerId == resource.data.ownerId
        && ((validStatusTransition() && ((request.resource.data.status == "accepted" && request.resource.data.driverId == request.auth.uid) ||
            (request.resource.data.status == "cancelledByClient" && isOwner()) ||
            (request.resource.data.status in ["onRoute", "completed", "cancelled", "cancelledByDriver"] && isDriver()))) ||
            (isRatingUpdate() && isOwner()));
    }

    match /driver_locations/{driverId} {
      allow read: if isSignedIn();
      allow write: if isSignedIn() && request.auth.uid == driverId;
    }

    match /users/{uid} {
      // Read: only owner (get by document ID)
      allow read: if isSignedIn() && request.auth.uid == uid;

      // SECURITY FIX: Removed unauthenticated list access (prevented phone enumeration)
      // List queries not needed for normal app flow - users access their own doc by UID
      // If phone lookup is needed, use Cloud Functions with proper rate limiting

      // Create: only owner
      allow create: if isSignedIn() && request.auth.uid == uid;

      // Update: only owner AND prevent tampering with sensitive/admin fields
      allow update: if isSignedIn()
                    && request.auth.uid == uid
                    // Prevent partial PIN edits (must update both pinHash and pinSalt together)
                    && !(request.resource.data.diff(resource.data).affectedKeys()
                         .hasAny(['pinHash','pinSalt'])
                         && !request.resource.data.keys().hasAll(['pinHash','pinSalt']))
                    // Prevent clients from modifying admin-only fields
                    && (!('totalTrips' in resource.data) || request.resource.data.totalTrips == resource.data.totalTrips)
                    && (!('averageRating' in resource.data) || request.resource.data.averageRating == resource.data.averageRating);

      // Saved locations subcollection: full CRUD for owner only
      match /savedLocations/{locationId} {
        allow read, delete: if isSignedIn() && request.auth.uid == uid;
        
        allow create: if isSignedIn() 
                      && request.auth.uid == uid
                      && request.resource.data.lat is number
                      && request.resource.data.lat >= -90
                      && request.resource.data.lat <= 90
                      && request.resource.data.lng is number
                      && request.resource.data.lng >= -180
                      && request.resource.data.lng <= 180
                      && request.resource.data.label is string;
        
        allow update: if isSignedIn() 
                      && request.auth.uid == uid
                      && request.resource.data.lat is number
                      && request.resource.data.lat >= -90
                      && request.resource.data.lat <= 90
                      && request.resource.data.lng is number
                      && request.resource.data.lng >= -180
                      && request.resource.data.lng <= 180
                      && request.resource.data.label is string;
      }
    }

    match /drivers/{driverId} {
      // Admin has full access to all drivers
      allow read, write: if isAdmin();

      // SECURITY FIX: Removed "|| true" - was allowing ANY authenticated user to read ANY driver
      // Read: only the driver themselves
      // Note: Order matching uses driver_locations collection, not /drivers
      allow read: if isSignedIn() && request.auth.uid == driverId;

      // SECURITY FIX: Removed unauthenticated list access (prevented phone enumeration)
      // List queries should use driver_locations for active drivers, not /drivers collection

      // Create: only the driver themselves
      allow create: if isSignedIn() && request.auth.uid == driverId;

      // Update: only the driver themselves
      // Allow updating any fields EXCEPT admin-only fields
      allow update: if isSignedIn()
                    && request.auth.uid == driverId
                    // Only check admin fields if they exist in the current document
                    && (!('isVerified' in resource.data) || request.resource.data.isVerified == resource.data.isVerified)
                    && (!('rating' in resource.data) || request.resource.data.rating == resource.data.rating)
                    && (!('totalTrips' in resource.data) || request.resource.data.totalTrips == resource.data.totalTrips)
                    && (!('ratedOrders' in resource.data) || request.resource.data.ratedOrders == resource.data.ratedOrders);
    }

    match /clients/{clientId} {
      // Admin has full access to all clients
      allow read, write: if isAdmin();
      
      // Read: only the client themselves
      allow read: if isSignedIn() && request.auth.uid == clientId;
      
      // Create: only the client themselves
      allow create: if isSignedIn() && request.auth.uid == clientId;

      // Update: only the client themselves AND prevent tampering with admin-only fields
      allow update: if isSignedIn() 
                    && request.auth.uid == clientId
                    && (!('isVerified' in resource.data) || request.resource.data.isVerified == resource.data.isVerified)
                    && (!('totalTrips' in resource.data) || request.resource.data.totalTrips == resource.data.totalTrips)
                    && (!('averageRating' in resource.data) || request.resource.data.averageRating == resource.data.averageRating);
    }

    match /admins/{adminId} {
      // Only admins can read admin documents
      allow read: if isAdmin();
      
      // No write access through client SDK (admins are managed via Cloud Functions)
      allow write: if false;
    }

    // Wallets collection (Phase 5)
    match /wallets/{walletId} {
      // Admins can read all wallets
      allow read: if isAdmin();
      
      // Drivers can read their own wallet
      allow read: if isSignedIn() && 
                     request.auth.uid == walletId &&
                     resource.data.type == 'driver';
      
      // Only Cloud Functions can write (no direct client writes)
      allow write: if false;
    }

    // Transactions collection (Phase 5)
    match /transactions/{transactionId} {
      // Admins can read all transactions
      allow read: if isAdmin();
      
      // Drivers can read their own transactions
      allow read: if isSignedIn() && 
                     request.auth.uid == resource.data.walletId;
      
      // Only Cloud Functions can write
      allow write: if false;
    }

    // Payouts collection (Phase 5)
    match /payouts/{payoutId} {
      // Admins can read all payouts
      allow read: if isAdmin();
      
      // Drivers can read their own payouts
      allow read: if isSignedIn() && 
                     request.auth.uid == resource.data.driverId;
      
      // Only Cloud Functions can write
      allow write: if false;
    }
  }
}